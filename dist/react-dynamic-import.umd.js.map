{"version":3,"file":"react-dynamic-import.umd.js","sources":["../src/index.js"],"sourcesContent":["/* eslint-disable react/prop-types */\nimport React, { forwardRef, useRef, useState, useEffect } from 'react';\n\nconst defaultErrorHandler = ({ name, error: { message } }) =>\n  `Unable to fetch module: ${name}.\\nError: ${message}.`;\n\nconst defaultPlaceholder = () => null;\n\n/**\n * Dynamically load any react module(Component or an HOC)\n *\n * @example\n *  - Module loader function\n *      const loader = f => import(`./dynamic/${f}.js`);\n *  - Use dynamic module(Make sure to use it outside render method, else new component is rendered in each render)\n *      const RealComponent = DynamicImport({ name: 'realModuleName', loader }),\n *\n * @param {Object} options - Options passed to react dynamic import functions\n * @param {Function} options.loader - function which takes module name and returns promise to resolve module\n * @param {Boolean} [options.isHOC=false] - Is the module an HOC?\n * @param {String} [options.name] - Dynamic module to be fetched(Mostly it will be part of the module file name),\n *                                        optional if loader returns same component every time\n * @param {Component} [options.placeholder=defaultPlaceholder] - React component to be rendered until actual module is fetched\n *                                                               (You can add UX improvements like adding small delay before showing\n *                                                               loader inside your class/functional component)\n * @param {Component} [options.errorHandler=defaultErrorHandler] - React component to be rendered if fetching actual module fails.\n *                                                                 This will receive `name` and `error` object as `props`\n */\nconst DynamicImportWrapper = ({\n  loader,\n  isHOC = false,\n  name,\n  placeholder: Placeholder = defaultPlaceholder,\n  errorHandler: ErrorHandler = defaultErrorHandler,\n}) => {\n  if (!loader || (loader && typeof loader !== 'function')) {\n    throw new Error(\"'loader' is required and should be of type 'function'.\");\n  }\n\n  function DynamicImport(props) {\n    const isMounted = useRef(false);\n    const [DynamicModule, setDynamicModule] = useState(null);\n    const [fetchError, setFetchError] = useState(null);\n    const { hocArgs, forwardedRef, ...rest } = props;\n\n    useEffect(() => {\n      isMounted.current = true;\n      const loaderPromise = loader(name);\n\n      if (\n        !loaderPromise ||\n        (loaderPromise && !(loaderPromise instanceof Promise))\n      ) {\n        throw new Error(\n          `Expected 'loader' to return a 'Promise', but, it returned '${typeof loaderPromise}' instead.`,\n        );\n      }\n\n      // Async await increases the bundle size\n      loaderPromise\n        .then(mod => {\n          if (isMounted.current) {\n            const m = mod.default || mod;\n\n            // useState executes the function if functional component is passed\n            setDynamicModule({ component: isHOC ? m(...hocArgs) : m });\n          }\n        })\n        .catch(err => {\n          if (isMounted.current) {\n            setFetchError(err);\n          }\n        });\n\n      return () => {\n        isMounted.current = false;\n      };\n    }, [hocArgs]);\n\n    if (fetchError) {\n      return <ErrorHandler error={fetchError} name={name} />;\n    }\n\n    return DynamicModule ? (\n      <DynamicModule.component {...rest} ref={forwardedRef} />\n    ) : (\n      <Placeholder name={name} />\n    );\n  }\n\n  DynamicImport.displayName = `DynamicImport${isHOC ? ':HOC' : ''}(${name ||\n    'Unknown'})`;\n\n  function DynamicImportFetcher(props, ref) {\n    return <DynamicImport {...props} forwardedRef={ref} />;\n  }\n  DynamicImportFetcher.displayName = 'DynamicImportFetcher';\n\n  const ComponentFetcher = forwardRef(DynamicImportFetcher);\n\n  const HOCFetcher = (...args) => {\n    function DynamicImportHOCFetcher(props, ref) {\n      return <DynamicImport {...props} forwardedRef={ref} hocArgs={args} />;\n    }\n    DynamicImportHOCFetcher.displayName = 'DynamicImportHOCFetcher';\n\n    return forwardRef(DynamicImportHOCFetcher);\n  };\n\n  return isHOC ? HOCFetcher : ComponentFetcher;\n};\n\nexport default DynamicImportWrapper;\n"],"names":["defaultErrorHandler","name","message","error","defaultPlaceholder","loader","isHOC","placeholder","Placeholder","errorHandler","ErrorHandler","Error","DynamicImport","props","isMounted","useRef","useState","DynamicModule","setDynamicModule","fetchError","setFetchError","hocArgs","forwardedRef","rest","useEffect","current","loaderPromise","Promise","then","mod","m","component","err","React","ref","DynamicImportFetcher","displayName","ComponentFetcher","forwardRef","args","DynamicImportHOCFetcher"],"mappings":"83DAG4B,SAAtBA,SAAyBC,IAAAA,KAAeC,IAATC,MAASD,gDACjBD,uBAAiBC,OAEnB,SAArBE,WAA2B,YAsBJ,gBAC3BC,IAAAA,WACAC,MAAAA,gBACAL,IAAAA,SACAM,YAAaC,aAAcJ,QAC3BK,aAAcC,aAAeV,QAExBK,GAAWA,GAA4B,mBAAXA,QACzB,IAAIM,MAAM,mEAGTC,EAAcC,OACfC,EAAYC,UAAO,OACiBC,WAAS,SAA5CC,OAAeC,WACcF,WAAS,SAAtCG,OAAYC,OACXC,EAAmCR,EAAnCQ,QAASC,EAA0BT,EAA1BS,aAAiBC,IAASV,qCAE3CW,YAAU,WACRV,EAAUW,SAAU,MACdC,EAAgBrB,EAAOJ,OAG1ByB,GACAA,KAAmBA,aAAyBC,eAEvC,IAAIhB,6EAC6De,yBAKzEA,EACGE,KAAK,SAAAC,MACAf,EAAUW,QAAS,KACfK,EAAID,WAAeA,EAGzBX,EAAiB,CAAEa,UAAWzB,EAAQwB,iBAAKT,IAAWS,aAGnD,SAAAE,GACDlB,EAAUW,SACZL,EAAcY,KAIb,WACLlB,EAAUW,SAAU,IAErB,CAACJ,IAEAF,EACKc,gBAACvB,GAAaP,MAAOgB,EAAYlB,KAAMA,IAGzCgB,EACLgB,gBAAChB,EAAcc,eAAcR,GAAMW,IAAKZ,KAExCW,gBAACzB,GAAYP,KAAMA,aAOdkC,EAAqBtB,EAAOqB,UAC5BD,gBAACrB,OAAkBC,GAAOS,aAAcY,KAJjDtB,EAAcwB,mCAA8B9B,EAAQ,OAAS,eAAML,GACjE,eAKFkC,EAAqBC,YAAc,2BAE7BC,EAAmBC,aAAWH,UAW7B7B,EATY,sCAAIiC,2BAAAA,2BACZC,EAAwB3B,EAAOqB,UAC/BD,gBAACrB,OAAkBC,GAAOS,aAAcY,EAAKb,QAASkB,YAE/DC,EAAwBJ,YAAc,0BAE/BE,aAAWE,IAGQH"}